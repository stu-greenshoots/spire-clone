/**
 * Art Configuration for Spire Ascent
 *
 * This file manages image assets for cards, enemies, relics, and potions.
 * Supports WebP (preferred) and PNG fallback formats.
 * Enemy sprites are bundled into a sprite sheet for performance.
 */

// Sprite sheet manifests (generated by scripts/generate-sprite-sheets.js)
import spriteManifest from './enemies/sprite-manifest.json';
import cardSpriteManifest from './cards/sprite-manifest.json';

// ============================================
// CARD ART CONFIGURATION (Sprite Sheet)
// ============================================

// Eagerly import card sprite sheet so Vite hashes and bundles it
const cardSpriteSheetModules = import.meta.glob('./cards/sprite-sheet.webp', { eager: true });
const cardSpriteSheetKey = Object.keys(cardSpriteSheetModules)[0];
const cardSpriteSheetUrl = cardSpriteSheetKey
  ? (typeof cardSpriteSheetModules[cardSpriteSheetKey] === 'string'
      ? cardSpriteSheetModules[cardSpriteSheetKey]
      : cardSpriteSheetModules[cardSpriteSheetKey]?.default)
  : null;

/**
 * Get sprite sheet info for a card.
 * Returns position data for CSS background-position rendering.
 */
export const getCardSpriteInfo = (cardId) => {
  if (!cardSpriteSheetUrl || !cardSpriteManifest?.cards?.[cardId]) {
    return null;
  }
  const entry = cardSpriteManifest.cards[cardId];
  return {
    hasSprite: true,
    spriteUrl: cardSpriteSheetUrl,
    x: entry.x,
    y: entry.y,
    cellSize: cardSpriteManifest.cellSize,
    sheetWidth: cardSpriteManifest.sheetWidth,
    sheetHeight: cardSpriteManifest.sheetHeight,
  };
};

/**
 * Check if an image exists for a card (fallback to individual files)
 * @param {string} cardId - The card ID
 * @returns {string|null} - Image URL or null if not found
 */
export const getCardImage = (cardId) => {
  try {
    const images = import.meta.glob(
      ['./cards/*.{webp,png,jpg,jpeg}', '!./cards/sprite-*'],
      { eager: true }
    );
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === cardId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

/**
 * Get card art info — tries sprite sheet first, falls back to individual image.
 */
export const getCardArtInfo = (cardId) => {
  // Try sprite sheet first
  const sprite = getCardSpriteInfo(cardId);
  if (sprite) {
    return {
      hasImage: true,
      imageUrl: null,
      sprite,
    };
  }
  // Fallback to individual image
  const image = getCardImage(cardId);
  return {
    hasImage: !!image,
    imageUrl: image,
    sprite: null,
  };
};

// ============================================
// ENEMY ART CONFIGURATION (Sprite Sheet)
// ============================================

// Eagerly import the sprite sheet so Vite hashes and bundles it
const spriteSheetModules = import.meta.glob('./enemies/sprite-sheet.webp', { eager: true });
const spriteSheetKey = Object.keys(spriteSheetModules)[0];
const spriteSheetUrl = spriteSheetKey
  ? (typeof spriteSheetModules[spriteSheetKey] === 'string'
      ? spriteSheetModules[spriteSheetKey]
      : spriteSheetModules[spriteSheetKey]?.default)
  : null;

/**
 * Get sprite sheet info for an enemy.
 * Returns position data for CSS background-position rendering.
 */
export const getEnemySpriteInfo = (enemyId) => {
  if (!spriteSheetUrl || !spriteManifest?.enemies?.[enemyId]) {
    return null;
  }
  const entry = spriteManifest.enemies[enemyId];
  return {
    hasSprite: true,
    spriteUrl: spriteSheetUrl,
    x: entry.x,
    y: entry.y,
    cellSize: spriteManifest.cellSize,
    sheetWidth: spriteManifest.sheetWidth,
    sheetHeight: spriteManifest.sheetHeight,
  };
};

// Fallback: individual image loading for enemies not in sprite sheet
export const getEnemyImage = (enemyId) => {
  try {
    const images = import.meta.glob(
      ['./enemies/*.{webp,png,jpg,jpeg}', '!./enemies/sprite-*'],
      { eager: true }
    );
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === enemyId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

export const getEnemyArtInfo = (enemyId) => {
  // Try sprite sheet first
  const sprite = getEnemySpriteInfo(enemyId);
  if (sprite) {
    return {
      hasImage: true,
      imageUrl: null,
      sprite,
    };
  }
  // Fallback to individual image
  const image = getEnemyImage(enemyId);
  return {
    hasImage: !!image,
    imageUrl: image,
    sprite: null,
  };
};

// ============================================
// RELIC ART CONFIGURATION
// ============================================

export const getRelicImage = (relicId) => {
  try {
    const images = import.meta.glob('./relics/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === relicId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

export const getRelicArtInfo = (relicId) => {
  const image = getRelicImage(relicId);
  return {
    hasImage: !!image,
    imageUrl: image,
  };
};

// ============================================
// POTION ART CONFIGURATION
// ============================================

export const getPotionImage = (potionId) => {
  try {
    const images = import.meta.glob('./potions/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === potionId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// EVENT ART CONFIGURATION
// ============================================

export const getEventImage = (eventId) => {
  try {
    const images = import.meta.glob('./events/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === eventId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// CHARACTER ART CONFIGURATION
// ============================================

export const getCharacterImage = (characterId) => {
  try {
    const images = import.meta.glob('./characters/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === characterId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// ORB ART CONFIGURATION (Defect)
// ============================================

export const getOrbImage = (orbType) => {
  try {
    const images = import.meta.glob('./orbs/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === orbType.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// BACKGROUND ART CONFIGURATION
// ============================================

export const getBackgroundImage = (actId) => {
  try {
    const images = import.meta.glob('./backgrounds/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === actId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// STANCE ART CONFIGURATION (Watcher)
// ============================================

export const getStanceImage = (stanceId) => {
  try {
    const images = import.meta.glob('./stances/*.{webp,png,jpg,jpeg}', { eager: true });
    const imagePath = Object.keys(images).find(path => {
      const filename = path.split('/').pop().split('.')[0];
      return filename.toLowerCase() === stanceId.toLowerCase();
    });
    if (!imagePath) return null;
    const imageModule = images[imagePath];
    return typeof imageModule === 'string' ? imageModule : imageModule.default;
  } catch {
    return null;
  }
};

// ============================================
// ENDLESS MODE VISUAL ESCALATION
// ============================================

/**
 * GD-31: Background shifts every 10 floors in endless mode.
 * Warm → cool → desaturated progression with increasing saturation/contrast.
 * Returns an inline style object for the game container background.
 */
export const getEndlessBackgroundStyle = (endlessLoop) => {
  // Each loop ≈ one pass through acts. Tier shifts every ~1 loop (every 10 floors).
  const tier = Math.min(endlessLoop, 10); // Cap at tier 10 for max intensity
  const t = tier / 10; // 0.0 → 1.0

  // Hue rotation: warm purple (270) → cool blue (220) → desaturated grey-blue (200)
  const hue = Math.round(270 - 70 * t);
  // Saturation increases then plateaus
  const sat = Math.round(25 + 35 * t);
  // Lightness of center: slightly brighter early, darker late
  const centerL = Math.round(18 + 8 * Math.sin(t * Math.PI));
  const midL = Math.round(12 - 3 * t);
  const edgeL = Math.round(8 - 4 * t);

  // Contrast boost via more pronounced gradient stops
  const center = `hsl(${hue}, ${sat}%, ${centerL}%)`;
  const mid = `hsl(${hue - 10}, ${Math.max(sat - 10, 10)}%, ${midL}%)`;
  const edge = `hsl(${hue - 15}, ${Math.max(sat - 15, 5)}%, ${edgeL}%)`;

  return {
    background: `radial-gradient(ellipse at center top, ${center} 0%, ${mid} 50%, ${edge} 100%)`
  };
};

// ============================================
// THEME SETTINGS
// ============================================

export const THEME_CONFIG = {
  // Color scheme (dark fantasy)
  colors: {
    primary: '#C9A84C', // Antique gold
    secondary: '#8B4513', // Saddle brown
    accent: '#6A5ACD', // Slate blue
    danger: '#8B0000', // Dark red
    success: '#2E8B57', // Sea green
    background: '#0a0a12', // Near black
    text: '#E8E0D0' // Parchment
  }
};

// Potion visual colors for UI rendering
export const POTION_COLORS = {
  fire_potion: { primary: '#ff4400', secondary: '#ff8800', glow: 'rgba(255, 68, 0, 0.4)' },
  block_potion: { primary: '#4488ff', secondary: '#88bbff', glow: 'rgba(68, 136, 255, 0.4)' },
  energy_potion: { primary: '#ffdd00', secondary: '#ffff88', glow: 'rgba(255, 221, 0, 0.4)' },
  explosive_potion: { primary: '#ff6600', secondary: '#ff9944', glow: 'rgba(255, 102, 0, 0.4)' },
  weak_potion: { primary: '#44aa44', secondary: '#88dd88', glow: 'rgba(68, 170, 68, 0.4)' },
  health_potion: { primary: '#cc0000', secondary: '#ff4444', glow: 'rgba(204, 0, 0, 0.4)' },
  strength_potion: { primary: '#cc2222', secondary: '#ff6666', glow: 'rgba(204, 34, 34, 0.4)' },
  dexterity_potion: { primary: '#22aa66', secondary: '#66ddaa', glow: 'rgba(34, 170, 102, 0.4)' },
  speed_potion: { primary: '#4466cc', secondary: '#88aaff', glow: 'rgba(68, 102, 204, 0.4)' },
  fear_potion: { primary: '#8844aa', secondary: '#bb88dd', glow: 'rgba(136, 68, 170, 0.4)' },
  fairy_potion: { primary: '#ffcc00', secondary: '#ffee88', glow: 'rgba(255, 204, 0, 0.5)' },
  cultist_potion: { primary: '#6622aa', secondary: '#9944dd', glow: 'rgba(102, 34, 170, 0.4)' },
  duplication_potion: { primary: '#aaaacc', secondary: '#ddddff', glow: 'rgba(170, 170, 204, 0.4)' },
  essence_of_steel: { primary: '#888899', secondary: '#bbbbcc', glow: 'rgba(136, 136, 153, 0.4)' },
  heart_of_iron: { primary: '#666677', secondary: '#9999aa', glow: 'rgba(102, 102, 119, 0.4)' },
};

export default {
  getBackgroundImage,
  getCardImage,
  getCardArtInfo,
  getCharacterImage,
  getEnemyImage,
  getEnemyArtInfo,
  getEnemySpriteInfo,
  getEventImage,
  getOrbImage,
  getRelicImage,
  getRelicArtInfo,
  getPotionImage,
  getStanceImage,
  THEME_CONFIG,
  POTION_COLORS
};
